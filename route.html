<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campus PathFinder - Full Network</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Leaflet CSS and JS for mapping -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Custom styles */
        body { font-family: 'Inter', sans-serif; background-color: #f4f6f8; }
        #map { height: 500px; width: 100%; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .leaflet-popup-content-wrapper, .leaflet-tooltip { border-radius: 0.5rem; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-8">
        <h1 class="text-3xl font-bold text-indigo-700 mb-2">Campus PathFinder</h1>
        <p class="text-gray-600 mb-6">Find the shortest route between any two points on campus using the full pathway network.</p>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <!-- Start Location Dropdown -->
            <div>
                <label for="startLocation" class="block text-sm font-medium text-gray-700 mb-1">Start Location</label>
                <select id="startLocation" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 shadow-sm"></select>
            </div>

            <!-- Destination Dropdown -->
            <div>
                <label for="endLocation" class="block text-sm font-medium text-gray-700 mb-1">Destination</label>
                <select id="endLocation" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 shadow-sm"></select>
            </div>

            <!-- Route Button -->
            <div class="flex items-end">
                <button id="findRouteButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out disabled:bg-indigo-300">
                    Find Route
                </button>
            </div>
        </div>

        <div id="distanceOutput" class="text-lg font-semibold text-gray-800 mb-4 h-6"></div>

        <!-- Map Container -->
        <div id="map"></div>
    </div>

    <script>
        function initCampusMap() {

            // --- 0. DATA INJECTION (POI and Full Pathway Network) ---

            const LOCATION_DATA = [
                { name: 'Gate 1 Entrance', initials: 'G1', lat: 14.857227, lon: 120.812314, color: 'red', icon: 'fa-location-arrow', description: 'The main entrance point for the campus.' },
                { name: 'Admissions Office', initials: 'AO', lat: 14.857390, lon: 120.812550, color: 'blue', icon: 'fa-user-plus', description: 'Where new student inquiries and enrollment are processed.' },
                { name: 'NSTP Building', initials: 'NB', lat: 14.856550, lon: 120.813550, color: 'green', icon: 'fa-users', description: 'National Service Training Program building.' },
                { name: 'Activity Center / Gymnasium', initials: 'AC', lat: 14.857313, lon: 120.813038, color: 'orange', icon: 'fa-trophy', description: 'Main venue for sports and large events.' },
                { name: 'BSU Main Library', initials: 'ML', lat: 14.858450, lon: 120.814300, color: 'darkpurple', icon: 'fa-book', description: 'The primary library resource center.' },
            ];

            const LOCATION_NAMES = {};
            LOCATION_DATA.forEach(loc => LOCATION_NAMES[loc.initials] = loc.name);


            // --- ALL Pathway segments extracted from 'routes pathways.txt' and 'Untitled map (2).kml' ---
            // Each inner array is a sequence of connected points (a road/path segment).
            const PATHWAY_SEGMENTS = [
                // Path 1: Gate 1 to Admissions Office (G1 -> AO)
                [
                    [14.85722371, 120.81231552], [14.85724479, 120.81234208], [14.85726313, 120.81236578],
                    [14.85727688, 120.81238665], [14.85729887, 120.81241130], [14.85730712, 120.81242932],
                    [14.85733462, 120.81244734], [14.85734201, 120.81245691], [14.85735520, 120.81247072],
                    [14.85736783, 120.81248408], [14.85738983, 120.81250873], [14.857390, 120.812550] // Near AO
                ],
                // Path 2: Admissions Office to NSTP Building (from KML and TXT)
                [
                    [14.857390, 120.812550], // Near AO
                    [14.8576, 120.81276], [14.85704, 120.81331], [14.8569, 120.81314],
                    [14.85689, 120.81313], [14.85688, 120.81312], [14.85687, 120.81312],
                    [14.85686, 120.81311], [14.85685, 120.81311], [14.85684, 120.81311],
                    [14.85683, 120.81312], [14.85682, 120.81312], [14.85681, 120.81314],
                    [14.85667, 120.81327], [14.856550, 120.813550] // Near NB
                ],
                // Path 3: Gate 1 to Activity Center / Gymnasium (G1 -> AC)
                [
                    [14.85723286, 120.81230926], // Near G1
                    [14.85760100, 120.81275988],
                    [14.85731322, 120.81303883] // Near AC
                ],
                // Path 4: Gate 1 to BSU Main Library (G1 -> ML)
                [
                    [14.857227, 120.812314], // Near G1
                    [14.857601, 120.812759],
                    [14.857850, 120.813100],
                    [14.858155, 120.814257],
                    [14.858450, 120.814300] // Near ML
                ],
                // Path 5: Admissions Office to NSTP Building (Another possible route, implied junction)
                [
                    [14.857390, 120.812550], // Near AO
                    [14.857500, 120.812800], // Junction A
                    [14.857000, 120.813000], // Junction B
                    [14.856550, 120.813550] // Near NB
                ]
            ];

            /**
             * Calculates the distance between two lat/lon points using the Haversine formula (in meters).
             */
            function haversine(lat1, lon1, lat2, lon2) {
                const R = 6371000; // Radius of Earth in meters
                const dLat = (lat2 - lat1) * (Math.PI / 180);
                const dLon = (lon2 - lon1) * (Math.PI / 180);
                const a =
                    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c; // Distance in meters
            }

            // --- 1. GRAPH CONSTRUCTION ---

            /**
             * Constructs the weighted graph from POIs and Pathway segments.
             * The crucial change here is iterating over segments to connect path nodes.
             */
            function buildGraph() {
                const G = {};       // Adjacency list: G[node_id] = [[neighbor_id, weight], ...]
                const nodeCoords = {}; // Maps node_id to [lat, lon]

                // 1. Add POIs to nodes
                LOCATION_DATA.forEach(loc => {
                    const nodeId = loc.initials;
                    nodeCoords[nodeId] = [loc.lat, loc.lon];
                    G[nodeId] = [];
                });

                // 2. Add Pathway coordinates and edges
                PATHWAY_SEGMENTS.forEach(segment => {
                    for (let i = 0; i < segment.length - 1; i++) {
                        const [latA, lonA] = segment[i];
                        const [latB, lonB] = segment[i + 1];

                        // Create unique IDs for non-POI nodes (using coordinates)
                        const nodeAId = `${latA.toFixed(6)},${lonA.toFixed(6)}`;
                        const nodeBId = `${latB.toFixed(6)},${lonB.toFixed(6)}`;

                        // Register nodes and coordinates
                        if (!nodeCoords[nodeAId]) {
                            nodeCoords[nodeAId] = [latA, lonA];
                            G[nodeAId] = [];
                        }
                        if (!nodeCoords[nodeBId]) {
                            nodeCoords[nodeBId] = [latB, lonB];
                            G[nodeBId] = [];
                        }

                        const distance = haversine(latA, lonA, latB, lonB);

                        // Add bidirectional edge
                        G[nodeAId].push([nodeBId, distance]);
                        G[nodeBId].push([nodeAId, distance]);
                    }
                });

                // 3. Connect POIs (buildings) to the nearest path node
                const allPathNodes = Object.keys(nodeCoords).filter(id => id.includes(','));

                LOCATION_DATA.forEach(poi => {
                    const poiId = poi.initials;
                    const [poiLat, poiLon] = nodeCoords[poiId];

                    let minDistance = Infinity;
                    let closestPathNodeId = null;

                    allPathNodes.forEach(pathNodeId => {
                        const [pathLat, pathLon] = nodeCoords[pathNodeId];
                        const dist = haversine(poiLat, poiLon, pathLat, pathLon);
                        if (dist < minDistance) {
                            minDistance = dist;
                            closestPathNodeId = pathNodeId;
                        }
                    });

                    if (closestPathNodeId && minDistance < 50) { // Only connect if close enough (50m threshold)
                        // Connect POI to its nearest path point
                        G[poiId].push([closestPathNodeId, minDistance]);
                        G[closestPathNodeId].push([poiId, minDistance]);
                    }
                });

                return { G, nodeCoords };
            }

            /**
             * Finds the shortest path using Dijkstra's algorithm.
             * Returns {pathCoords: [(lat, lon), ...], totalDistance: number}
             */
            function dijkstra(graph, startNode, endNode, nodeCoords) {
                if (!graph[startNode] || !graph[endNode]) return { pathCoords: [], totalDistance: 0 };

                let distances = {};
                let previous = {};
                let pq = [[0, startNode]]; // [distance, node_id]

                for (let node in graph) {
                    distances[node] = Infinity;
                    previous[node] = null;
                }
                distances[startNode] = 0;

                while (pq.length) {
                    pq.sort((a, b) => a[0] - b[0]);
                    let [distance, currentNode] = pq.shift();

                    if (distance > distances[currentNode]) continue;
                    if (currentNode === endNode) break;

                    for (let [neighbor, weight] of graph[currentNode]) {
                        let newDistance = distance + weight;
                        if (newDistance < distances[neighbor]) {
                            distances[neighbor] = newDistance;
                            previous[neighbor] = currentNode;
                            pq.push([newDistance, neighbor]);
                        }
                    }
                }

                let path = [];
                let current = endNode;
                while (current) {
                    path.unshift(current);
                    current = previous[current];
                }

                const routeCoords = path.map(nodeId => nodeCoords[nodeId]).filter(c => c);
                const totalDistance = distances[endNode] === Infinity ? 0 : distances[endNode];

                return { pathCoords: routeCoords, totalDistance };
            }

            const { G, nodeCoords } = buildGraph();


            // --- 2. MAP SETUP (Leaflet) ---

            const centerLat = 14.857500;
            const centerLon = 120.813500;
            const map = L.map('map').setView([centerLat, centerLon], 17);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(map);

            let routeLayer = L.layerGroup().addTo(map);

            // Add POI Markers
            LOCATION_DATA.forEach(loc => {
                const marker = L.marker([loc.lat, loc.lon], {
                    icon: L.divIcon({
                        className: 'custom-div-icon',
                        // Tailwind utility classes for color based on loc.color, adjusted for safety
                        html: `<div class="bg-blue-600 text-white p-2 rounded-full shadow-lg flex items-center justify-center font-bold text-xs transform -translate-x-1/2 -translate-y-1/2" style="width: 32px; height: 32px; background-color: ${loc.color};">${loc.initials}</div>`,
                        iconSize: [32, 32],
                        iconAnchor: [16, 16]
                    })
                }).addTo(map);

                marker.bindPopup(`
                    <h4 class="font-bold text-indigo-700">${loc.name}</h4>
                    <p class="text-sm text-gray-600">${loc.description}</p>
                `);
            });

            // --- 3. UI and Event Handling ---

            const startSelect = document.getElementById('startLocation');
            const endSelect = document.getElementById('endLocation');
            const findButton = document.getElementById('findRouteButton');
            const distanceOutput = document.getElementById('distanceOutput');

            // Populate Dropdowns
            LOCATION_DATA.forEach(loc => {
                const optionStart = new Option(`${loc.name} (${loc.initials})`, loc.initials);
                const optionEnd = new Option(`${loc.name} (${loc.initials})`, loc.initials);
                startSelect.add(optionStart);
                endSelect.add(optionEnd);
            });

            // Set initial values
            startSelect.value = 'G1';
            endSelect.value = 'ML'; // Changed initial destination to Library for demonstration

            // Find Route Handler
            findButton.addEventListener('click', () => {
                const startId = startSelect.value;
                const endId = endSelect.value;

                if (startId === endId) {
                    distanceOutput.innerHTML = `<span class="text-red-600">Start and end locations must be different.</span>`;
                    return;
                }

                // Run Dijkstra's
                const { pathCoords, totalDistance } = dijkstra(G, startId, endId, nodeCoords);

                // Clear previous route
                routeLayer.clearLayers();

                if (pathCoords.length > 1) {
                    // Draw new path
                    const polyline = L.polyline(pathCoords, {
                        color: '#6366f1', // Indigo 500
                        weight: 8,
                        opacity: 0.8
                    }).addTo(routeLayer);

                    // Fit map bounds to the route
                    map.fitBounds(polyline.getBounds().pad(0.1));

                    // Add custom start/end markers on the path
                    L.marker(pathCoords[0], {
                        icon: L.divIcon({
                            className: 'start-icon',
                            html: '<div class="bg-green-500 text-white p-1 rounded-full shadow-lg flex items-center justify-center" style="width: 30px; height: 30px;"><i class="fa fa-shoe-prints"></i></div>',
                            iconSize: [30, 30], iconAnchor: [15, 15]
                        })
                    }).addTo(routeLayer).bindTooltip(`Start: ${LOCATION_NAMES[startId]}`);

                    L.marker(pathCoords[pathCoords.length - 1], {
                        icon: L.divIcon({
                            className: 'end-icon',
                            html: '<div class="bg-black text-white p-1 rounded-full shadow-lg flex items-center justify-center" style="width: 30px; height: 30px;"><i class="fa fa-flag-checkered"></i></div>',
                            iconSize: [30, 30], iconAnchor: [15, 15]
                        })
                    }).addTo(routeLayer).bindTooltip(`End: ${LOCATION_NAMES[endId]}`);

                    // Display distance
                    distanceOutput.innerHTML = `<span class="text-green-600">Shortest Route Found: </span>${totalDistance.toFixed(2)} meters`;
                } else {
                    distanceOutput.innerHTML = `<span class="text-red-600">Path not found. The locations may be disconnected in the provided map data.</span>`;
                }
            });

            // Trigger initial route calculation on load
            findButton.click();
        }

        window.onload = initCampusMap;
    </script>
</body>
</html>